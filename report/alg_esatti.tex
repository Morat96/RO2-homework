\chapter{Exact Algorithms}

On this chapter we will describe exact algorithms based on the Dantzig–Fulkerson– Johnson formulation, described in chapter 1. The main problem of this model is that the formulation has $O(2^n)$ SECs, so it is impossibile to implement all the constraints in the model since it would result in a very high execution time and memory usage even for small graphs.
\\ For this reason, SECs constraints are added only when necessary in the model, in order to discard solutions with cycles. Using this technique, hopefully, only a small part of $O(2^n)$ SECs are added to the model.
\\ The main algorithms that make use of this technique are Loop methods and CPLEX callbacks.

\section{Loop Methods}
On this section we will describe two iterative approaches in order to solve the DFJ model without adding an exponential number of Cycle constraints.
\subsection{Simple Loop}
The first approach, that we called Simple Loop, is presented in Algorithm 1.
\\ In line 2, we initialize the model with the variables, the degree constraints and the objective function. 
The algorithm then proceeds solving the problem within a while loop (lines 3-4), and in each iteration we check if the the optimal solution has more than one component (line 5). If so, we add, for each component, the corresponding subtour elimination. Instead, If the optimal solution has one component (lines 7-8), i.e. a Hamiltonian cycle, then we return the optimal solution found (line 9).
\\ This algorithm turns out very efficient, especially with recent solvers. Its efficiency is due to the fact that the solution is solved very fast, especially in first iterations, and only small number of SECs are added (line 6) at each iteration. These constraints permits to prevent a lot solutions with subtours to the original problem. 
\\ At worst, since the problem is NP-hard, all constraints will be added to the model, requiring exponential computational time, but in most cases this is not the case.
It may seem that this method is not very efficient, but with recent, increasingly sophisticated solvers, this method can lead to the optimal solution, even with many nodes, in a few seconds.
\begin{algorithm}
    \caption{Simple Loop}\label{Loop Method}
    \hspace*{\algorithmicindent} \textbf{Input:} $G = (V,E) , c : E \rightarrow \mathbb{R}$\\
    \hspace*{\algorithmicindent} \textbf{Output:} $z \text{*} $ optimal solution to TSP on the input graph $G$
    \begin{algorithmic}[1]
    \State $\textit{done} \gets \textit{false}$
    \State model $ \leftarrow $ \textbf{$\ast$ Initialize variables and objective function $\ast$ }
    \While {!done} 
    	\State $z \text{*} \gets \text{optimal\_solution}(\text{model})$\;
	\If{$components(z\text{*}) > 1$} 
	\State \textbf{ $\ast$ Add to the model SECs for each connected component $\ast$ }
	
	\Else \State $\textit{done} \gets \textit{true}$
	\EndIf	
    \EndWhile
    \State \textbf{return} $z \text{*} $
    \end{algorithmic}
    \end{algorithm}
\noindent
\subsection{Heuristic Loop}
The Algorithm 1 has a drawback, since at each iteration we solve to the optimum the TSP problem, even if the constraints collected until that point, are not sufficient to achieve the true optimum. In other words, we must wait that the solver finds out the optimal solution, even if the constraints avaiable may allow solutions with subtours.
\\ For this reason, we implemented an ``heuristic" version of the method seen before. This method is composed of two phases. 
For this reason, we implemented an ``heuristic" version of the method seen before. This method is composed of two phases. The first phase is used to collecting some SEC constraints, relaxing the optimality concept, setting for example an higher value for the solution GAP or limiting the solution in the root node of the branching tree.
This phase permits add useful constraints to the model, without computing the optimal solution in each iteration. In fact, with this phase we can obtain a lot of useful SECs in a short time, especially in the first iterations.
This phase is active until the solution found has more than one component, from then on, will be activated the second phase. 
In the second phase, the ``relaxation" of the solver is removed, solving essentially the problem with the Simple Loop method and this ensure that the solution computed is the true optimal solution.
\\ The Heuristic Loop, is presented in Algorithm 2. In line 4, as with the first method, we initialize the model with the variables, the degree constraints and the objective function.
At beginning the first phase is active (line 2), which means that some CPLEX parameters have to be setted (line 5) in order to obtain a non-optimal solution, speeding up the computational time. In our case, we decided to set two CLEX parameters, that is, the solution's GAP and the NODE lim. The first parameter force CPLEX to stop, when the solution found until that point has a GAP of a certain value (for example 5\%). The second parameter specifies the node of the branching tree until which CPLEX can compute the solution, for example, if the value of the parameter is setted to 0, CPLEX can compute the solution only in the root node.
The algorithm then proceeds solving the problem within a while loop (line 6). As in the Simple Loop, at each iteration we check if the solution has more than one component, and if so, we add, for each component, the corresponding subtour elimination. Instead, If the optimal solution has one component, we set the flag \textit{second\_phase} to true (line 15) and reset the solver settings, thus ensuring that the solution found from now on it will be an optimal solution.
During the first phase, we have collected, hopefully, a number of useful SEC constraints in a small amount of time, with respect to found the optimal solution at each iteration.
For the second phase, please refer to the Simple Loop (Algorithm 1).
\begin{algorithm}
    \caption{Heuristic Loop}\label{Loop Method}
    \hspace*{\algorithmicindent} \textbf{Input:} $G = (V,E) , c : E \rightarrow \mathbb{R}$\\
    \hspace*{\algorithmicindent} \textbf{Output:} $z \text{*} $ optimal solution to TSP on the input graph $G$
    \begin{algorithmic}[1]
    \State $\textit{done} \gets \textit{false}$
    \State $\textit{first\_phase} \gets \textit{true}$
    \State $\textit{second\_phase} \gets \textit{false}$
    \State model $ \leftarrow $ \textbf{$\ast$ Initialize variables and objective function $\ast$ }
    \State CPXsetintparam $ \leftarrow $ \textbf{$\ast$ Set MIP Gap and/or Node lim in order to obtain a non-optimal solution $\ast$ }
    \While {!done} 
    	\If{$second\_phase$} 
	\State CPXsetintparam $ \leftarrow $\textbf{ $\ast$ Return to original solver setting in order to obtain an optimal solution $\ast$ }
	\State $\textit{second\_phase} \gets \textit{false}$
	\EndIf
    	\State $z \text{*} \gets \text{optimal\_solution}(\text{model})$\;
	\If{$components(z\text{*}) > 1$} 
	\State \textbf{ $\ast$ Add to the model SECs for each connected component $\ast$ }
	\EndIf
	\If{$ components(z\text{*}) == 1 \And first\_phase$} 
	\State $\textit{first\_phase} \gets \textit{false}$
	\State $\textit{second\_phase} \gets \textit{true}$
	\EndIf
	\If{$ components(z\text{*}) == 1 \And !first\_phase$} 
	\State $\textit{done} \gets \textit{true}$
	\EndIf
    \EndWhile
    \State \textbf{return} $z \text{*} $
    \end{algorithmic}
    \end{algorithm}
    
\newpage
\section{Callbacks}

